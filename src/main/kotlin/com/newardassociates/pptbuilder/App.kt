/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.newardassociates.pptbuilder

import com.newardassociates.pptbuilder.nop.NOPProcessor
import com.newardassociates.pptbuilder.pptx.PPTXProcessor
import com.newardassociates.pptbuilder.reveal.RevealProcessor
import com.newardassociates.pptbuilder.slidy.SlidyProcessor
import com.newardassociates.pptbuilder.text.TextProcessor
import kotlinx.cli.*
import java.io.File
import java.io.FileInputStream
import java.util.*
import java.util.logging.LogManager
import java.util.logging.Logger
import java.util.logging.Level

fun main(args: Array<String>) {
    println("pptbuilder v0.9 (Build v.20211015)") // TODO replace with Build-Timestamp from manifest
    println("------------------------------")
    val cliParser = ArgParser("pptbuilder")

    val input by cliParser.argument(ArgType.String, description = "Input file")
    val output by cliParser.argument(ArgType.String, description = "Output file name").optional()

    val outputDirectory by cliParser.option(ArgType.String, fullName = "outputDir", shortName = "d",
            description = "Output directory into which to place the generated file").default("")

    val verbosity by cliParser.option(ArgType.Choice(listOf("quiet", "warning", "info", "debug"), {it}),
            fullName = "verbosity", shortName = "v",
            description = "How much logging to display").default("warning")
    val format by cliParser.option(ArgType.Choice(listOf("pptx", "reveal", "slidy", "text", "nop"), {it}),
            fullName = "format", shortName = "f",
            description = "Output format to use").default("pptx")
    val template by cliParser.option(ArgType.String,
            fullName = "template", shortName = "t",
            description = "The processing template file to use to start from (pptx only)").default("")

    cliParser.parse(args)

    // Configure LogManager according to verbosity flag
    Logger.getLogger(::main.javaClass.packageName).level = when (verbosity) {
        "quiet" -> Level.SEVERE
        "info" -> Level.INFO
        "debug" -> Level.FINE
        else -> Level.WARNING
    }

    // Grab default properties from .pptbuilder.properties
    val properties = Properties()
    val propertiesFile = "${System.getProperty("user.home")}/.pptbuilder.properties"
    if (File(propertiesFile).exists())
        properties.load(FileInputStream(propertiesFile))
    println("... using properties from ${propertiesFile}: $properties")

    // Design thought:
    // Does it make more sense to import the CLI args into the properties, and then
    // pull the values out of there, rather than what I'm doing here?

    val inputPath = File(input).path
    val inputFile = File(input).name

    val outputPath = if (outputDirectory != "") outputDirectory else (properties["outputPath"] ?: ".").toString() + "/"
    val outputFile = if (output != null) output else inputFile.substringBeforeLast(".")

    val templateFile = (if (template != "") template else (properties["template"] ?: "")).toString()

    println("... parsing ${inputPath}/${inputFile} to ${outputPath}${outputFile}${if (templateFile != "") " using ${templateFile}..." else ""}...")

    /*
        val outputFilename : String = "",
        val templateFile : String = "",
        val baseDirectory : String = "",
        val noTitleSlide : Boolean = false,
        val noNotesSlides : Boolean = false
     */
    val processorOptions = Processor.Options(
            outputFilename = outputPath + outputFile,
            templateFile = templateFile
    );

    // It's just too much fun to NOT do all of this in one compound expression
    (when (format) {
        //"ast" -> ASTProcessor(processorOptions)
        "nop" -> NOPProcessor(processorOptions)  // just for verifying input, don't generate output
        //"impress" -> ImpressProcessor(processorOptions)  // for HTML/impress.js
        "pptx" -> PPTXProcessor(processorOptions)
        "reveal" -> RevealProcessor(processorOptions)  // for HTML/reveal.js
        "slidy" -> SlidyProcessor(processorOptions)  // for HTML Slidy
        "text" -> TextProcessor(processorOptions)
        //"webslides" -> WebSlidesProcessor(processorOptions)  // for HTML WebSlides
        else -> throw IllegalArgumentException("Unrecognized format: " + format.toString())
    }).process(Parser(properties).parse(File(input)))
}
